<#
	.SYNOPSIS
	MakeSystemCatalog.ps1 processes an input set of XML and a collection of DUP packages
	to produce an output XML file that serves as a Base Catalog for Dell Repository Manager (DRM).

	.DESCRIPTION
	The script processes a set of <System> nodes defined in the input XML file that are each identified by 
	a platform Name such as 'DSS9600' and a BIOS systemID. Each <System> also defines a list of DUP packages
	by binary file name (ex. BIOS_XX64W_LN_1.5.4.BIN) and Agile Folder number (ex. FOLDER05077911M) that 
	comprise the list of update packages that are desired to be delivered for that platform.
	
	The script extracts details from the DUP packages and compiles the XML file necessary to import into 
	Dell Repository Manager (DRM) as a Base Catalog for the purpose of creating update repositories in order to 
	generate deliverable update scripts. It also ensures that the .BIN and .BIN.sign files for each DUP 
	package are copied to the correct folders in the DRM Store location on the local system, assuming that DRM 
	is installed on the local system.
	
	Using the Base Catalog generated by this script systems that are not included in the standard Dell 
	catalogs for DRM can be supported for DRM-style update deliverables, such as creating a file share repository, 
	or a Linux-based Smart Deployment Script (SDS).
	
	At present, only the Linux OS is supported for DUP packages and Base Catalogs.
	
	.PARAMETER SystemNames
	An array of strings [string[]] that determines which of the predefined <System> nodes from the SystemDataFile 
	will be included in the OutputCatalog.

	.PARAMETER SystemDataFilePath
	A string that specified the full path and file name of the SystemDataFile, an XML file that defines all of 
	the <System> nodes and their required packages and identifying information. This cannot be null or empty.
	
	.PARAMETER OutputCatalogPath
	A string that specifies the full path and file name of the OutputCatalogPath, a file that will be created by 
	the script and can be used as a Base Catalog in DRM.  This cannot be null or empty.
	
	.PARAMETER DUPSearchPath
	A string that specifies the root folder under which to search for DUP packages by filename.  No specific 
	folder structure is required but it is assumed that all DUPs for all systems will be found under one path 
	hierarchy.  If more than one copy of a DUP is present the first one found will be used.
	
	.EXAMPLE
	.\MakeSystemCatalog.ps1 -SystemNames 'DSS9600','DCS1610' -SystemDataFilePath 'c:\work\ATT_Updates\ATTSystemData.xml' -OutputCatalogPath 'c:\work\ATT_Updates\ATTBaseCatalog.xml' -DUPSearchPath 'c:\work\ATT_Updates\'
	
	.NOTES
		Requires the following installs:
			Powershell 5.0 (included in Microsoft Windows 10)
			GIT for Windows in order to use sh.exe to extract the .BIN file contents. (https://git-scm.com/download/win)
			
		Some Warning messages may appear during execution.  This is normal. The script will attempt to supply any 
		missing information from the DUP packages with schema-appropriate XML.
		
		Add the -Verbose option to the command line to see more details about the operation of the script.
		
		To view Debug messages set the value $DebugPreference = 'Continue' at the command line before executing.
#>
[cmdletbinding()] 
param(
	[parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string[]]$SystemNames, 
	[parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string]$SystemDataFilePath,
	[parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string]$OutputCatalogPath,
	[parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string]$DUPSearchPath
)

Class DellSystem {
	[string] $Name
	[string] $Nickname
	[string] $Agile
	[System.XML.XMLElement]  $TargetSystems
	[System.XML.XMLElement]  $TargetOSes
	[Hashtable[]] $Packages
	[int] $SizeBytes
	[string]$DateStamp

	DellSystem([System.XML.XMLElement]$SystemNode) {
		write-verbose "DellSystem:  Constructing object for name $($systemnode.Name)"
		$this.Name = $SystemNode.Name
		$this.NickName = $SystemNode.NickName
		$this.Agile = $SystemNode.Agile
		$this.TargetSystems = $SystemNode.SelectSingleNode("TargetSystems")
		$this.TargetOSes = $SystemNode.SelectSingleNode("TargetOSes")
		
		# collect packages
		
		$this.Packages = @()
		foreach ($pkgnode in $SystemNode.GetElementsByTagName("Package")) {
			$pkg = @{}
			$pkg.path = $pkgnode.path
			$pkg.Folder = $pkgnode.Folder
			$this.Packages += $pkg
		}
		$this.DateStamp = (Get-Date -format 'yyyy-MM-ddTHH:mm:ss') + (Get-timezone).BaseUtcOffset.ToString().Substring(0,6)
	}

	# utility method to generate the ubiquitous <Display "lang"="en"> </Display> structures
	[System.XML.XMLElement] MakeLangDisplayElement([System.XML.XMLDocument]$doc, [string]$TagName, [string]$Text) {
		write-verbose "DellSystem:  Generating Display XML for tag $tagname with innertext '$Text'"
		[System.XML.XMLElement]$elem = $doc.CreateElement($TagName)
		$display = $doc.CreateElement('Display')
		$display.SetAttribute('lang','en')
		$display.InnerText = $Text
		$elem.AppendChild($display)
		
		return $elem
	}
	

	# Create the SoftwareBundle node and structure, return as XMLElement
	[System.XML.XMLElement] GetSWBundle([System.XML.XMLDocument]$xmldoc) {
		write-verbose "DellSystem:  Generating SoftwareBundle XML for System named $($this.Name)"
		[System.XML.XMLElement]$swbun = $xmldoc.CreateElement("SoftwareBundle")
		$swbun.SetAttribute('schemaVersion','2.0')
		$ID = "$($this.Agile)_LIN.670"
		$vver = "$($this.Agile).670"
		$path = "PE$($this.Name)-LX-$($this.Agile).XML"
		$swbun.SetAttribute('releaseID', $ID)
		$swbun.SetAttribute('bundleID', $ID)
		$swbun.SetAttribute('dateTime', $this.DateStamp)
		$swbun.SetAttribute('vendorVersion', $vver)
		$swbun.SetAttribute('path', $path)
		$swbun.SetAttribute('bundleType', 'BTLX')
		$swbun.SetAttribute('size', "0")
		$swbun.AppendChild($this.MakeLangDisplayElement($xmldoc, 'Name', "System Bundle (Linux) PE$($this.Name) 670"))
		$elem = $this.MakeLangDisplayElement($xmldoc, 'ComponentType', 'Dell System Bundle')
		$elem.SetAttribute('value','SBDL')
		$swbun.AppendChild($elem)
		$swbun.AppendChild($this.MakeLangDisplayElement($xmldoc, 'Description', "System Bundle (Linux) PE$($this.Name) 670"))
		$elem = $this.MakeLangDisplayElement($xmldoc, 'Category', 'OpenManage Systems Management')
		$elem.SetAttribute('value','SM')
		$swbun.AppendChild($elem)
		
		$newnode = $xmldoc.ImportNode($this.TargetSystems, $true)
		$swbun.AppendChild($newnode)
		$newnode = $xmldoc.ImportNode($this.TargetOSes, $true)
		$swbun.AppendChild($newnode)
		$swbun.AppendChild($this.MakeLangDisplayElement($xmldoc, 'RevisionHistory', "-"))
		$elem = $this.MakeLangDisplayElement($xmldoc, 'ImportantInfo', "-")
		$elem.SetAttribute('URL','http://support.dell.com')
		$swbun.AppendChild($elem)
		
		# add packages
		$content = $xmldoc.CreateElement("Contents")
		$swbun.AppendChild($content)
		
		foreach ($pkg in $this.Packages) {
			$elem = $xmlDoc.CreateElement("Package")
			$elem.SetAttribute('path',$pkg.Path)
			$content.AppendChild($elem)
		}
	
		return $swbun
	}
	
	[Hashtable[]]GetPackageList() {
		return $this.Packages
	}

}  # DellSystem

Class DellSystemCatalogs {
	[string]$XMLFileName
	[System.XML.XMLDocument]$XMLDoc
	[DellSystem[]]$Systems
	[string]$DateStamp
	[string]$Version
	[System.XML.XMLElement[]]$SysNodes
	[hashtable[]]$Components
	[string]$DRMStorePath
	
	DellSystemCatalogs([string]$XMLFileName) {
		$this.XMLFileName = $XMLFileName
		$this.XMLDoc = [System.XML.XMLDocument]::new()
		$this.XMLDoc.Load($this.XMLFileName)
		
		if (-not $this.XMLDoc.BaseCatalogs) {
			throw "Unable to load BaseCatalogs from $($this.XMLFileName)"
		}
		
		write-verbose "DellSystemCatalogs: Getting BaseCatalogs from $($this.XMLFileName)"
		
		$this.SysNodes = $this.XMLDoc.BaseCatalogs.GetElementsByTagName("System")
		
		$this.Systems = @()
		foreach ($sysnode in $this.SysNodes) {
			write-verbose "DellSystemCatalogs: Found System named $($sysNode.Name)"
			$this.Systems += [DellSystem]::new($sysnode)
		}
		
		$this.DateStamp = (Get-Date -format 'yyyy-MM-ddTHH:mm:ss') + (Get-timezone).BaseUtcOffset.ToString().Substring(0,6)
		$this.Version = get-date -format 'yy.MM.dd'
		$this.Components = @()
		$this.DRMStorePath = join-path "$([Environment]::GetFolderPath([System.Environment+SpecialFolder]::CommonApplicationData))" 'Dell\drm\store'
	}
	
	[System.XML.XMLElement] MakeLangDisplayElement([System.XML.XMLDocument]$doc, [string]$TagName, [string]$Text) {
		[System.XML.XMLElement]$elem = $doc.CreateElement($TagName)
		$display = $doc.CreateElement('Display')
		$display.SetAttribute('lang','en')
		$display.InnerText = $Text
		$elem.AppendChild($display)
		
		return $elem
	}
	
	[System.XML.XMLElement] MakeInvColElement([System.XML.XMLDocument]$doc, [string[]]$attributes) {
		[System.XML.XMLElement]$elem = $doc.CreateElement('InventoryComponent')
		foreach ($attrib in $attributes) {
			$name,$value = $attrib.Split('=').trim('"')
			$elem.SetAttribute($name, $value)
		}
		return $elem
	}
	
	[void] AddComponents([Hashtable[]]$MoreComponents, [string]$supportedsystem) {
		if (-not $this.Components) {
			$this.Components = @()
		}
		
		foreach ($comp in $MoreComponents) {
			# check for duplicates by path (filename)
			if (-not ($this.Components | ? {$_.Path -eq $comp.Path})) {
				write-verbose "DellSystemCatalogs: AddComponents: Adding $($comp.Path) with support for $supportedsystem"
				$comp.SupportedSystems = @($supportedsystem)
				$this.Components += $comp
			}
			else {
				write-verbose "DellSystemCatalogs: AddComponents: Adding supported system $supportedsystem to $($comp.Path)"
				$existcomp = $this.Components | ? {$_.Path -eq $comp.Path} | select -first 1
				$existcomp.SupportedSystems += $supportedsystem
				
				write-debug "DellSystemCatalogs: AddComponents: $($comp.path) SupportedSystems = $($comp.SupportedSystems)"
			}
		}
	}
	
	# search the software bundles for the given component 
	[System.XML.XMLElement] GetSupportedSystemsXML([Hashtable]$comp, [System.XML.XMLDocument]$xmldoc) {
	<#
	  <Brand key="3" prefix="PE">
        <Display lang="en"><![CDATA[PowerEdge]]></Display>
        <Model systemID="07C3" systemIDType="BIOS">
          <Display lang="en"><![CDATA[DSS9600]]></Display>
        </Model>
      </Brand>
      <Brand key="69" prefix="PEC">
	#>
		
		if (-not ($comp.SupportedSystems)) {
			write-warning "DellSystemCatalogs: GetSupportedSystems: no supported systems found for $($comp.path)"
			return $null
		}
		write-verbose "DellSystemCatalogs: GetSupportedSystems: Component $($comp.path) supports the following systems: $($comp.SupportedSystems)"
		$sptsys = $this.Systems | ? {$_.Name -in $comp.SupportedSystems}  # get the objects for the systems
		
		
		$sptsysnode = $xmldoc.CreateElement('SupportedSystems')
		$sptsysnode.SetAttribute('display','1')
		foreach ($sys in $sptsys) {
			write-debug "DellSystemCatalogs: GetSupportedSystems: Component $($comp.path) adding Brand/model info from system $($sys.Name)"
			$brands = $sys.TargetSystems.GetElementsByTagName('Brand')
			$nodebrands = $sptsysnode.GetElementsByTagName('Brand')
			foreach ($brand in $brands) {
				$found = $false
				# search to make sure we don't add duplicates
				$models = $brand.GetElementsByTagName('Model')
				foreach ($nodebrand in $nodebrands) {
					if ($nodebrand.key -eq $brand.key) {
						$found = $true
						write-debug "Found brandkey $($nodebrand.key)"
						# add the models under the existing brand
						
						$nodemodels = $nodebrand.GetElementsByTagName('Model')
						foreach ($model in $models) {
							$foundm = $false
							foreach ($nodemodel in $nodemodels) {
								if ($model.systemID -eq $nodemodel.systemID) {
									$foundm = $true
									write-debug "Found model $($model.systemID) under brandkey $($nodebrand.key)"
									break # no need to do anything else if found
								}
							}
							if (-not $foundm) {
								# add each model under the brand
								write-debug "Importing model $($model.systemID) info into brand $($nodebrand.key)"
								$newnode = $xmldoc.ImportNode($model, $true)
								$nodebrand.AppendChild($newnode)
							}

						}
						break  # no need to search if found
					}
				}
				if (-not $found) {
					# add the brand node and all model subnodes from TargetSystems
					write-debug "Importing brand $($brand.key) into SupportedSystems"
					$newnode = $xmldoc.ImportNode($brand, $true)
					$sptsysnode.AppendChild($newnode)
				}
			}
		}
		
		return $sptsysnode
	}
	
	
	# extract xml from DUP and return as SoftwareComponent Element
	[System.XML.XMLElement] GetSWCompXML([hashtable]$comp, [System.XML.XMLDocument]$xmldoc, [string]$DUPSearchPath) {
		write-verbose "DellSystemCatalogs: GetSWCompXML: Generating SoftwareComponent XML for path $($comp.path)"
		
		if (-not (test-path $DUPSearchPath)) {
			throw "DellSystemCatalogs: GetSWCompXML: Package Search Path $DUPSearchPath does not exist."
		}
		$pf = get-childitem -path $DUPSearchPath -filter $comp.path -recurse | select -first 1
		
		if (-not $pf) {
			throw "DellSystemCatalogs: GetSWCompXML: Package file $($comp.path) not found under search path $DUPSearchPath."
		}
		else {
			$pkgxmlpath = join-path $DUPSearchPath ($pf.basename + '.xml')
		}
		
		[System.XML.XMLElement]$swcomp = $xmldoc.CreateElement('SoftwareComponent')

		#get the bounds of the XML content
		$maniftxmlmarker = grep -m1 -an "^#####Startofpackage#####" $($pf.fullname) | cut -d ":" -f 1
		$duparchivemarker = grep -m1 -an "^#####Startofarchive#####" $($pf.fullname) | cut -d ":" -f 1
		$pkgxmlend = [Convert]::ToInt32($duparchivemarker) - 2
		$pkgxmlstart = [Convert]::ToInt32($maniftxmlmarker) + 1
		
		write-debug "XML data in $($pf.fullname) starts at line $pkgxmlstart and ends at $pkgxmlend"
		
		# cut the file into the xml part only
		write-verbose "DellSystemCatalogs: GetSWCompXML: Extracting XML to target file $pkgxmlpath"
		$cmdstr = "sh -c 'head -n $pkgxmlend $($pf.fullname.replace('\','/')) | tail -n +$pkgxmlstart > $($pkgxmlpath.replace('\','/'))'"
		write-debug "Command line: $cmdstr"
		invoke-expression "& $cmdstr"
		
		[System.XML.XMLDocument]$pkgxml = [System.XML.XMLDocument]::new()
		$pkgxml.Load($pkgxmlpath)
		
		$swcomproot = $pkgxml.SelectSingleNode("//SoftwareComponent")

		$swcomp.SetAttribute('schemaVersion', '2.4')
		$swcomp.SetAttribute('packageID', $swcomproot.packageID.tostring().substring(0,5))
		$swcomp.SetAttribute('releaseID', $swcomproot.releaseID.tostring().substring(0,5))
		$swcomp.SetAttribute('hashMD5', (get-filehash -path $pf.FullName -algorithm 'MD5').Hash.tolower())
		$swcomp.SetAttribute('path', "$($comp.folder)\1\$($comp.path)")
		$swcomp.SetAttribute('dateTime', $swcomproot.dateTime)
		$swcomp.SetAttribute('releaseDate', $swcomproot.releaseDate)
		$swcomp.SetAttribute('vendorVersion', $swcomproot.vendorVersion)
		$swcomp.SetAttribute('dellVersion', $swcomproot.dellVersion)
		$swcomp.SetAttribute('packageType', $swcomproot.packageType)
		$swcomp.SetAttribute('rebootRequired', $swcomproot.rebootRequired)
		$swcomp.SetAttribute('size', $pf.length)
		
		foreach ($nodename in @('Name','ComponentType','Description','LUCategory','Category','SupportedDevices','SupportedSystems','RevisionHistory','ImportantInfo','Criticality')) {
			$node = $swcomproot.SelectSingleNode("//$nodename")
			
			if ($node) { 
				$elem = $xmldoc.ImportNode($node, $true)
				$swcomp.AppendChild($elem)
			}
			else {
				write-warning "DellSystemCatalogs: GetSWCompXML: Node named $nodename not found in component $($comp.path) package XML."
			}
		}
		
		# fix stuff
		$devices = $swcomp.SelectSingleNode("//SupportedDevices")
		if ($devices) {
			$rollback = $devices.SelectSingleNode("//RollbackInformation")
			while ($rollback) {
				$rollback.parentNode.RemoveChild($rollback)
				$rollback = $devices.SelectSingleNode("//RollbackInformation")
			}
			$payload = $devices.SelectSingleNode("//PayloadConfiguration")
			while ($payload) {
				$payload.ParentNode.RemoveChild($payload)
				$payload = $devices.SelectSingleNode("//PayloadConfiguration")
			}
		}
		if (-not $swcomp.SelectSingleNode("//SupportedSystems")) {
			write-verbose "DellSystemCatalogs: GetSWCompXML: Constructing SupportedSystems node for $($comp.Path)"
			$supsys = $this.GetSupportedSystemsXML($comp, $xmldoc)
			if ($supsys) {
				$swcomp.AppendChild($supsys)
			}
			else {
				write-warning "DellSystemCatalogs: GetSWCompXML: No Supported Systems found for component $($comp.path)."
			}
		}
		if (-not $swcomp.SelectSingleNode("//RevisionHistory")) {
			write-verbose "DellSystemCatalogs: GetSWCompXML: Constructing RevisionHistory node for $($comp.Path)"
			$elem = $this.MakeLangDisplayElement($xmldoc, 'RevisionHistory', '-')
						
			$swcomp.AppendChild($elem)
		}
		remove-item $pkgxmlpath  # cleanup
		return $swcomp
	}

	
	[void] CreateBaseCatalogXML([string[]] $SystemNames, [string]$OutputXMLFile, [string]$DUPSearchPath) {
		write-verbose "Creating all-inclusive base catalog for $SystemNames to file named $OutputXMLFile"
		[System.XML.XMLDocument]$OutputDoc = [System.XML.XMLDocument]::new()
		$dec = $outputdoc.CreateXmlDeclaration("1.0","utf-16", $null)
		$outputdoc.AppendChild($dec)

		[System.XML.XMLElement]$Manifest = $OutputDoc.CreateElement("Manifest")
		
		# make main headers
		$Manifest.SetAttribute('baseLocation',"ftp.dell.com")
		$Manifest.SetAttribute('dateTime', $this.DateStamp)
		$Manifest.SetAttribute('identifier', (new-guid))
		$Manifest.SetAttribute('releaseID', "ABCDE")
		$Manifest.SetAttribute('version', $this.Version)
		$Manifest.SetAttribute('predecessorID', (new-guid))

		$relnotes = $this.MakeLangDisplayElement($outputdoc, "ReleaseNotes", 'Release Notes')
		$Manifest.AppendChild($relnotes)
		
		$attribset2 = @('schemaVersion="2.0"','releaseID="VPJT7"','hashMD5="708e3774b98db772566007a092bbd218"','path="FOLDER05077911M/1/invcol_VPJT7_LN64_18_06_000_248_A00"','dateTime="2018-07-09T10:50:31Z"','releaseDate="July 09, 2018"','vendorVersion="18.06.000.248"','dellVersion="A00"','osCode="LIN64"')
		$invcolnode = $this.MakeInvColElement($outputdoc, $attribset2)
		$Manifest.AppendChild($invcolnode)
		
		#  Make Linux SoftwareBundle per system
		foreach ($name in $SystemNames) {
			$sys = $this.Systems | ? {$_.Name -eq $name}
			if (-not $sys) {
				write-error "A DellSystem object with the name $name was not found in the collection."
			}
		
			[System.XML.XMLElement]$bundle = $sys.GetSWBundle($OutputDoc)
			$Manifest.AppendChild($bundle)
			$this.AddComponents($sys.GetPackageList(), $sys.Name)
		}
		
		# make a SoftwareComponent per package
		write-verbose "DellSystemCatalogs:  Generating SoftwareComponent list"
		foreach ($comp in $this.Components) {
			$elem = $this.GetSWCompXML($comp, $outputdoc, $DUPSearchPath)
			$Manifest.AppendChild($elem)
		}
		
		$elem = $outputdoc.CreateElement("Prerequisites")
		$Manifest.AppendChild($elem)
		
		$outputdoc.AppendChild($Manifest)
		
		
		$OutputDoc.Save($OutputXMLFile)
	}
	
	# assumes that CreateBaseCatalogXML was already completed so that Components list is populated
	# will copy the bin and bin.sign files to the appropriate folder in DRM store
	# so that DRM can generate the export packages by whatever means selected.
	[void] SetupDellRepoMgrStore() {
		write-verbose "DellSystemCatalogs: SetupDellRepoMgrStore: Copying SoftwareComponent bin files to Dell Repo Mgr Store."
		
		if (-not (test-path $this.DRMStorePath)) {
			throw "DellSystemCatalogs: SetupDellRepoMgrStore:  Dell Repo Mgr Store path not found at $($this.DRMStorePath)."
		}
		
		foreach ($comp in $this.Components) {
			$pfbin = get-childitem -path $this.DUPSearchPath -filter $comp.path -recurse | select -first 1
			
			if (-not $pfbin) {
				write-warning "DellSystemCatalogs: SetupDellRepoMgrStore:  Component file $($comp.path) not found in $($this.DUPSearchPath)."
			}
			$pfsign = get-item "$($pfbin.fullname).sign"
			if (-not $pfsign) {
				write-warning "DellSystemCatalogs: SetupDellRepoMgrStore:  Component file $($comp.path) not found in $($this.DUPSearchPath)."
			}			
			$pkgpath = "$($comp.folder)\1\"
			$targetpath = join-path $this.DRMStorePath $pkgpath
			$targetbin = join-path $targetpath $pfbin.name
			$targetsign = join-path $targetpath $pfsign.Name
			
			if (-not (test-path $targetpath)) {
				new-item -ItemType Directory -path $targetpath
			}
			
			if (-not ((test-path $targetbin) -and (test-path $targetsign))) {
				write-verbose "DellSystemCatalogs: SetupDellRepoMgrStore: Copying $($pfbin.fullname) to $targetpath."
				copy-item -Force -Path $pfbin.FullName -Destination $targetpath
				write-verbose "DellSystemCatalogs: SetupDellRepoMgrStore: Copying $($pfsign.fullname) to $targetpath."
				copy-item -Force -Path $pfsign.Fullname -Destination $targetpath
			}
			else {
				write-verbose "DellSystemCatalogs: SetupDellRepoMgrStore: Component $($pfbin.Name) already in $targetpath."
			}
		}
	}
}

$dsc = [DellSystemCatalogs]::new($SystemDataFilePath)
$dsc.CreateBaseCatalogXML($systemnames, $OutputCatalogPath, $DUPSearchPath )
$dsc.SetupDellRepoMgrStore()